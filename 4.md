# 今日任务

- 添加拦截器以检测用户登录情况

- 完成下订单功能

- 完成订单管理功能

- 其他功能

- 项目总结

  

# 拦截器

某些页面是需要用户事先登录后，才能显示，如果未登录，将重定向到登录页。

如果在每个控制器中都取判断 Session 是否存在，将会十分麻烦，使用拦截器可以解决这一问题。

## 概述

在`Spring Boot`中，拦截器是一种用于拦截和处理`HTTP`请求的机制。它是`Spring`框架提供的一种中间件，用于在请求到达控制器（`Controller`）之前或之后执行一些共享的逻辑。

`Spring Boot`的拦截器基于`Spring MVC`框架中的`HandlerInterceptor`接口实现。通过创建一个自定义的拦截器类并实现`HandlerInterceptor`接口，可以定义拦截器要执行的逻辑和行为。

## 定义拦截器

在`Spring Boot`中定义拦截器十分的简单，只需要创建一个拦截器类，并实现`HandlerInterceptor`接口即可。

`HandlerInterceptor`接口中定义以下`3`个方法，如下表：

| 返回值类型 | 方法声明                                                     | 描述                                                         |
| :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| boolean    | preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) | 该方法在控制器处理请求方法前执行，其返回值表示是否中断后续操作，返回true表示继续向下执行，返回false表示中断后续操作。 |
| void       | postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) | 该方法在控制器处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步修改。 |
| void       | afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) | 该方法在视图渲染结束后执行，可以通过此方法实现资源清理、记录日志信息等工作。 |

它接收三个参数：

- HttpServletRequest request: 表示当前的HTTP请求
- HttpServletResponse response: 表示当前的HTTP响应
- Object handler: 表示被拦截的处理器（一般是Controller中的方法）

## 自定义拦截器

```java
package org.example.interceptor;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        Object user = request.getSession().getAttribute("user");
        if(null != user){
            return true;
        }
        request.setAttribute("msg", "请先登录");
        request.getRequestDispatcher("/login").forward(request,response);
        return false;
    }
}
```

代码中的`preHandle`方法是拦截器的主要方法，在目标方法调用之前执行。

在`preHandle`方法中，首先通过`request.getSession(false)`获取当前请求的`HttpSession`对象（如果存在的话），然后判断该`HttpSession`对象是否为`null`并且是否存在名为"session_userinfo"的属性。如果这个条件成立，说明用户已经登录，可以继续执行后续的业务，于是返回`true`，否则验证失败，将`HTTP`响应的状态码设置为`401`，表示未授权，然后返回`false`，不再继续执行后续业务

## 注册拦截器

```java
package org.example.config;

import org.example.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class AdminWebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/","/login","/register", "/favicon.ico", "/css/**","/js/**","/fonts/**","/font-awesome/**","/img/**","/admin/**");
    }
}
```

- addPathPatterns 要拦截的 URL

- excludePathPatterns 要放行的 URL

# 其他功能开发

- 完成下订单功能
- 完成订单的管理（显示订单列表、删除订单）
- 完成充值功能
- 选择性完成其他扩展功能（如付款、用户退出登录、订单完成后的商品评价）

