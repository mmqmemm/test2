# 今日任务

- SpringBoot 整合 Mybatis Plus

- 完成注册 / 登录

- 完成管理员--商品分类管理

- 完成管理员--商品管理

  

# SpringBoot 整合 JdbcTemplate

1，准备数据库

user 表

| id     | name(用户名) | password(密码) | nickname(昵称) | balance(余额) |
| ------ | ------------ | -------------- | -------------- | ------------- |
| bigint | varchar(50)  | varchar(50)    | varchar(50)    | decimal(10,2) |

2，添加 JDBC 依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.27</version>
</dependency>
```

3，配置数据源

**resources/application.yml**

```yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mall?useSSL=false&serverTimezone=UTC
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
```

4，测试

```java
@Autowired
JdbcTemplate jdbcTemplate;

@Test
public void t1(){
    long c = jdbcTemplate.queryForObject("select count(*) from user", Long.class);
    System.out.println(c);
}
```



# SpringBoot 整合 MyBatis Plus

MyBatis 是一个开源、轻量级的数据持久化框架，是 JDBC 和 Hibernate 的替代方案。MyBatis 内部封装了 JDBC，简化了加载驱动、创建连接、创建 statement 等繁杂的过程，开发者只需要关注 SQL 语句本身。

![Mybatis图标](https://c.biancheng.net/uploads/allimg/210708/1-210FQ43322D7.png)

> 数据持久化是将内存中的数据模型转换为存储模型，以及将存储模型转换为内存中数据模型的统称。例如，文件的存储、数据的读取以及对数据表的增删改查等都是数据持久化操作。

MyBatis 支持定制化 SQL、存储过程以及高级映射，可以在实体类和 SQL 语句之间建立映射关系，是一种半自动化的 ORM 实现。其封装性低于 Hibernate，但性能优秀、小巧、简单易学、应用广泛。

> ORM（Object Relational Mapping，对象关系映射）是一种数据持久化技术，它在对象模型和关系型数据库之间建立起对应关系，并且提供了一种机制，通过 JavaBean 对象去操作数据库表中的数据。

MyBatis 前身为 IBatis，2002 年由 Clinton Begin 发布。2010 年从 Apache 迁移到 Google，并改名为 MyBatis，2013 年又迁移到了 Github。

MyBatis 的主要思想是将程序中的大量 SQL 语句剥离出来，使用 XML 文件或注解的方式实现 SQL 的灵活配置，将 SQL 语句与程序代码分离，在不修改程序代码的情况下，直接在配置文件中修改 SQL 语句。

MyBatis 与其它持久性框架最大的不同是，MyBatis 强调使用 SQL，而其它框架（例如 Hibernate）通常使用自定义查询语言，即 HQL（Hibernate查询语言）或 EJB QL（Enterprise JavaBeans查询语言）。

MyBatis 官方文档：https://mybatis.org/mybatis-3/zh/

#### 优点

- MyBatis 是免费且开源的。
- 与 JDBC 相比，减少了 50% 以上的代码量。
- MyBatis 是最简单的持久化框架，小巧并且简单易学。
- MyBatis 相当灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL 写在 XML 中，和程序逻辑代码分离，降低耦合度，便于同一管理和优化，提高了代码的可重用性。
- 提供 XML 标签，支持编写动态 SQL 语句。
- 提供映射标签，支持对象与数据库的 ORM 字段关系映射。
- 支持存储过程。MyBatis 以存储过程的形式封装 SQL，可以将业务逻辑保留在数据库之外，增强应用程序的可移植性、更易于部署和测试。

## 快速入门

1，准备数据库

user 表

| id     | name(用户名) | password(密码) | nickname(昵称) | balance(余额) |
| ------ | ------------ | -------------- | -------------- | ------------- |
| bigint | varchar(50)  | varchar(50)    | varchar(50)    | decimal(10,2) |

2, 导入依赖

```xml
<!-- Mybatis plus -->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-spring-boot3-starter</artifactId>
    <version>3.5.12</version>
</dependency>
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-jsqlparser</artifactId>
    <version>3.5.12</version>
</dependency>
<!-- MySQL JDBC驱动 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.27</version>
</dependency>
```

3，配置 application.yml

```yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mall?useSSL=false&serverTimezone=UTC
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
```

4, 编写实体类，与表对应

```java
package org.example.entity;

public class User {

    private Long id;
    private String name;
    private String password;
    private String nickname;
    private Double balance;

    public User() {
    }

    public User(String name, String password, String nick, Double balance) {
        this.balance = balance;
        this.nickname = nick;
        this.password = password;
        this.name = name;
    }
    /* 省略 getter 和 setter */
}
```

>  如果使用**lombok**插件，可以简化实体类的编写
>
> Idea 安装 Lombok 插件
>
> 引入依赖：
>
> ```xml
> <dependency>
>      <groupId>org.projectlombok</groupId>
>      <artifactId>lombok</artifactId>
>      <version>1.18.32</version>
>      <scope>provided</scope>
> </dependency>
> ```
>
> 使用 @Data 注解：
>
> ```java
> package org.example.entity;
> 
> @Data
> public class User {
>     private Long id;
>     private String name;
>     private String password;
>     private String nickname;
>     private Double balance;
> }
> ```

5, 编写 Mapper 接口

```java
package org.example.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import org.example.entity.User;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface UserMapper extends BaseMapper<User> {
}
```

**注意**：@Mapper 注解

6, 测试

```java
package org.example;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import mp.entity.Users;
import mp.mapper.UserMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;

@SpringBootTest
public class Test1 {
    @Autowired
    UserMapper userMapper;

    @Test
    public void t0(){
        List<Users> users = userMapper.selectList(null);
        for (Users user : users){
            System.out.println(user);
        }
    }
}
```

### 实体类名与表名的处理

Mybatis会自动寻找与实体类名同名的表名，并进行相应的操作；也会自动寻找与实体类属性名同名的字段名，并进行操作。但有时两者并不一致，这时可采用以下注解指定：

```java
// 表名指定
@TableName("user")
public class Users{}
    
//字段名指定
@TableField("department")
private String dept;
```

### 注解实现映射

可以看到，由于 UserMapper 继承了 BaseMapper，已经可以实现一些查询。但为了实现更灵活、复杂的查询，可以自定义 UserMapper 方法。

```java
@Mapper
public interface UserMapper extends BaseMapper<Users> {

    @Select("select id,name from user")
    List<Users> allUsers();
}
```

在该方法中，使用 **@Select** 注解实现了自定义查询。

关于更多的注解，参考：https://c.biancheng.net/mybatis/annotation.html



### Mapper XML 实现映射

如果 SQL 语句存在动态 SQL 或者比较复杂，使用注解写在 Java 文件里可读性差，且增加了维护的成本。所以一般建议使用 XML 文件配置的方式，避免重复编写 SQL 语句。

通常，XML 文件名与 Mapper 一致，例如：UserMapper.xml，存放路径在：**resources/mapper/** 下，如：

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.example.mapper.UserMapper">
    <select id="selectPage" resultType="org.example.entity.User">
        select * from user
    </select>
    <select id="selectUserByNameAndPass" resultType="org.example.entity.User">
        SELECT id,name,password,nickname,balance FROM user WHERE name=#{name} and password=#{password}
    </select>

    <insert id="insertUser" parameterType="org.example.entity.User">
        INSERT INTO user(name,password,nickname,balance) VALUES(#{name},#{password},#{nickname},#{balance})
    </insert>
</mapper>
```

每一个 id 对应 Mapper 接口中的一个方法名。

当然，也可以配置 xml 文件的路径，例如，在 application.yml 中：

```yml
mybatis-plus:
  mapper-location: classpath*:/mapper/*Mapper.xml
```



更多关于标签的使用，参考 https://c.biancheng.net/mybatis/select.html



## Serivce 接口

在实际开发中，通常不会在 Controller 中直接调用 Mapper 接口，而是在 Service 中使用它。

创建 org.example.service.UserService

```java
public interface IUserService extends IService<User> {
    int registerUser(User user);
    User login(String name, String password);
}
```

这里 IUserService 继承了 Mybatis Plus 提供的 IService 接口，使用更加方便。



## ServiceImpl 实现类

```java
package org.example.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.example.entity.Users;
import org.example.service.UserService;
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
}
```

**注意**：@Service 注解

### 测试

```java
@SpringBootTest
public class Test1 {
    @Resource
    UserService userService;

    @Test
    public void t0(){
        List<Users> list = userService.list();
        for (Users user : list){
            System.out.println(user);
        }
    }
}
```

### 更多

可以看到，UseService 接口已经具备了许多查询方法。另外，它也可以调用 UserMapper 接口执行更多的复杂查询。这点请自行实验。



## QueryWrapper

在 MyBatis-Plus 中，`QueryWrapper` 是一个非常强大的条件构造器，它允许你构建各种复杂的查询条件。通过使用 `QueryWrapper`，你可以轻松地构造 SQL 查询语句，而不需要直接编写 SQL 语句。



<u>详解 MyBatis-Plus 框架中 QueryWrapper 类</u>

https://blog.csdn.net/2302_79730293/article/details/147640544



# 日志系统

SpringBoot 集成了日志系统，默认使用 Slf4j + logback 实现

## 日志级别

由低到高：ALL, TRACE，DEBUG，INFO，WARN，ERROR，FATAL，OFF

只会打印指定级别以上的日志

- ALL：所有日志
- TRACE：追踪，一般不使用
- DEBUG：开发测试
- INFO：信息
- WARN：警告
- ERROR：错误，异常
- FATAL：致命错误，如 JVM 奔溃
- OFF：关闭所有日志

默认级别是**INFO**

## 配置

application.yml中配置

```
logging.level.<loggername>=<level>
如：logging.level.root=warn
```

Java:

```java
Logger logger = LoggerFactory.getLogger(getClass());
logger.info("");

// 使用 lombok
log.info("");
```



# 图片上传

1，上传表单，必须 post 方式提交；必须有 enctype

```html
<form action="xxx" method="post" enctype="multipart/form-data">
    
</form>
```

2，配置上传文件夹

application.yml

```yml
prop:
  # 图片文件路径
  upload-folder: E:/images/
```

3，org.example.controller.admin.AdminGoodsController
可以使用 **@Value** 注解读取属性值并注入

```java
@Controller
@RequestMapping("/admin/goods")
public class AdminGoodsController {

    @Value("${prop.upload-folder}")
    private String uploadFolder;

    @PostMapping("/newGoods")
    public String doNewGoods(int categoryId, String name, String title, String detail, double price, int stock, MultipartFile img){
        if (img.isEmpty()) {
            //model.addAttribute("msg", "上传文件为空");
            return "error";
        }

        Map map = FileUtil.saveImg(img, uploadFolder);

        if (!(Boolean) map.get("state")) {
            //model.addAttribute("msg", "文件上传发生错误");
            return "error";
        }
        String fileName = map.get("fileName").toString();

        Goods goods = new Goods();
        goods.setName(name);
        goods.setCategoryId(categoryId);
        goods.setTitle(title);
        goods.setDetail(detail);
        goods.setStock(stock);
        goods.setPrice(price);
        goods.setImg(fileName);
        goodsService.newGoods(goods);
        return "redirect:/admin/goods/newGoods";
    }
}
```

util.FileUtil

```java
package org.example.util;

import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class FileUtil {

    /**
     * 获取uuid  用于唯一标识
     *
     * @return 返回去除横杆的uuid
     */
    public static String getUID() // 设置getUID方法
    {
        return UUID.randomUUID().toString().replace("-", "");
    }

    /**
     * 获取当前时间转换为字符串
     *
     * @return 返回时间类型 yyyy-MM-dd HH:mm:ss
     */
    public static String getToday()
    {	return new SimpleDateFormat("yyyy-MM-dd").format(new Date());	}

    /**
     * 对图片进行保存
     * @param file 要保存的图片
     * @param path 保存的路径
     * @return
     */
    public static Map<String,Object> saveImg(MultipartFile file, String path) {
        Map<String, Object> map = new HashMap<>();
        map.put("state", true);
        String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(".") + 1, file.getOriginalFilename().length());
        if (!"jpg,jpeg,gif,png".toUpperCase().contains(suffix.toUpperCase())) {
          map.put("state",false);
          map.put("errorInfo","图片文件格式不正确，只能上传jpg,jpeg,gif,png格式图片！");
          return map;
        }
        File savePath = new File(path);
        if (!savePath.exists()) {
            //若不存在该目录，则创建目录
            savePath.mkdir();
        }
        //通过UUID生成唯一文件名
        String fileName = getUID() + "." + suffix;
        map.put("fileName", fileName);
        try {
            //将文件保存指定目录
            file.transferTo(new File(path + fileName));
        } catch (Exception e) {
            e.printStackTrace();
            map.put("state", false);
            map.put("errorInfo", "文件保存出错，请重新上传！");
            return map;
        }
        return map;
    }

    public static boolean deleteFile(String path){
        File file = new File(path);
        return file.delete();
    }
}
```



# 图片读取控制器

```java
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * 图片URL控制器 - 提供图片访问地址
 */
@RestController
@RequestMapping("api")
public class ImageUrlController {
    @Value("${prop.upload-folder}")
    private String uploadFolder;
    /**
     * 通过ResponseEntity方式返回图片资源
     *
     * @param filename 要获取的图片文件名，如"example.jpg"
     * @return 包含图片二进制数据的ResponseEntity对象
     */
    @GetMapping("/image/{filename}")
    public ResponseEntity<Resource> getImage(@PathVariable String filename) {
        // 构建图片文件的完整路径，确保路径存在且有访问权限
        String filePath = uploadFolder + filename;
        Path path = Paths.get(filePath);

        try {
            // 创建资源对象，用于加载文件内容
            Resource resource = new UrlResource(path.toUri());

            // 检查资源是否存在并可读，防止返回不存在的资源
            if (!resource.exists() || !resource.isReadable()) {
                // 资源不存在或不可读时，返回404状态码
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
            }

            // 自动检测文件的MIME类型，确保浏览器能正确解析图片格式
            String contentType = Files.probeContentType(path);
            if (contentType == null) {
                // 无法检测到MIME类型时，使用通用二进制流类型
                contentType = "application/octet-stream";
            }

            // 构建并返回包含图片资源的HTTP响应
            return ResponseEntity.ok()
                    // 设置内容类型，通知浏览器接收的是什么类型的图片
                    .contentType(MediaType.parseMediaType(contentType))
                    // 设置Content-Disposition头，指示浏览器内联显示图片而非下载
                    .header(HttpHeaders.CONTENT_DISPOSITION,
                            "inline; filename=\"" + URLEncoder.encode(filename, "UTF-8") + "\"")
                    // 将图片资源作为响应体返回
                    .body(resource);
        } catch (MalformedURLException e) {
            // 处理URL格式错误异常，可能是文件路径格式有问题
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        } catch (IOException e) {
            // 处理IO异常，如文件读取失败或编码问题
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }
}
```

# 超级项目数据库和表

user 用户表

| id     | name(用户名) | password(密码) | nickname(昵称) | balance(余额) |
| ------ | ------------ | -------------- | -------------- | ------------- |
| bigint | varchar(50)  | varchar(50)    | varchar(50)    | decimal(10,2) |

category 分类表

| id   | name(分类名) |
| ---- | ------------ |
| int  | varchar(50)  |

goods 商品表

| id     | name(商品名) | title(商品标题) | category_id(商品分类) | img(图片)     | detail（详情） | price(价格)   | stock(库存）) |
| ------ | ------------ | --------------- | --------------------- | ------------- | -------------- | ------------- | ------------- |
| bigint | varchar(50)  | varchar(50)     | varchar(50)           | decimal(10,2) | varchar(100)   | decimal(10,2) | int           |

review 评价表

| id     | goods_id(商品ID) | author(作者) | time(时间) | content(内容) | img(图片)    |
| ------ | ---------------- | ------------ | ---------- | ------------- | ------------ |
| bigint | bigint           | varchar(50)  | datetime   | varchar(100)  | varchar(100) |

order 订单表

| id     | user_id(用户ID) | goods_id(商品ID) | goods_name(昵商品名称) | img(图片)    | price(价格)   | status(状态) | create_time | pay_time |
| ------ | --------------- | ---------------- | ---------------------- | ------------ | ------------- | ------------ | ----------- | -------- |
| bigint | bigint          | biging           | varchar(50)            | varchar(100) | decimal(10,2) | tinyint      | datetime    | datetime |

数据库创建脚本

```sql
CREATE DATABASE mall;
USE mall;

SET NAMES utf8mb4;
SET UNIQUE_CHECKS = 0;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for user
-- ----------------------------
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL COMMENT '手机号码作为用户名',
  `password` varchar(50) NOT NULL COMMENT '用MD5加密',
  `nickname` varchar(50) NOT NULL COMMENT '昵称',
  `balance` decimal(10,2) DEFAULT 0 COMMENT '余额',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';


-- ----------------------------
-- Table structure for review
-- ----------------------------
CREATE TABLE `review` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `goods_id` bigint(20) NOT NULL COMMENT '商品ID',
  `author` varchar(50) NOT NULL COMMENT '作者',
  `time` datetime NOT NULL COMMENT '时间',
  `content` varchar(100) NOT NULL COMMENT '内容',
  `img` varchar(100) DEFAULT NULL COMMENT '图片',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品评价表';

-- ----------------------------
-- Table structure for goods
-- ----------------------------
CREATE TABLE `goods` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL COMMENT '名称',
  `title` varchar(50) NOT NULL COMMENT '标题',
  `img` varchar(100) DEFAULT NULL COMMENT '图片',
  `detail` varchar(100) NOT NULL COMMENT '详情',
  `price` decimal(10,2) NOT NULL COMMENT '价格',
  `stock` int(11) NOT NULL DEFAULT 0 COMMENT '库存；-1表示没有限制',
  `browse_count` int(11) DEFAULT 0 COMMENT '浏览数',
  `category_id` tinyint(4) DEFAULT 0 COMMENT '商品类别Id',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品表';

CREATE TABLE `category` (
  `id` tinyint(4) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品类别表';

-- ----------------------------
-- Table structure for order
-- ----------------------------
CREATE TABLE `orders` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `goods_id` bigint(20) DEFAULT NULL COMMENT '商品ID',
  `goods_name` varchar(50) DEFAULT NULL COMMENT '商品名称',
  `img` varchar(100) DEFAULT NULL COMMENT '商品图片',
  `price` decimal(10,2) DEFAULT NULL COMMENT '订单价格',
  `status` tinyint(4) DEFAULT 0 COMMENT '订单状态：0-新建未支付；1-已支付；',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `pay_time` datetime DEFAULT NULL COMMENT '支付时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='订单表';

SET UNIQUE_CHECKS = 1;
SET FOREIGN_KEY_CHECKS = 1;
```



# 作业

- 完成注册 / 登录
- 完成管理员--登录功能

> 为简化开发，默认管理员为 admin，密码为 123456

- 完成管理员--商品分类管理
- 完成管理员--新增商品、商品管理

